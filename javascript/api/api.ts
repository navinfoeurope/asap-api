/* tslint:disable */
/* eslint-disable */
/**
 * Adversarial Security Assessment Platform for AI
 * Adversarial Security Assessment Platform for AI API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: info@navinfo.eu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface APIKeyResponse
 */
export interface APIKeyResponse {
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponse
     */
    creationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponse
     */
    expiryDate?: string;
    /**
     * 
     * @type {number}
     * @memberof APIKeyResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponse
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponse
     */
    keyId?: string;
    /**
     * 
     * @type {string}
     * @memberof APIKeyResponse
     */
    lastUsedDate?: string;
}
/**
 * 
 * @export
 * @interface AuthorizedUserResponse
 */
export interface AuthorizedUserResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthorizedUserResponse
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizedUserResponse
     */
    jsonSettings?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizedUserResponse
     */
    jwt?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizedUserResponse
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorizedUserResponse
     */
    registered?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthorizedUserResponse
     */
    roles?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizedUserResponse
     */
    uid?: string;
}
/**
 * 
 * @export
 * @interface DataSet
 */
export interface DataSet {
    /**
     * 
     * @type {string}
     * @memberof DataSet
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DataSet
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataSet
     */
    format?: string;
    /**
     * 
     * @type {number}
     * @memberof DataSet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DataSet
     */
    name?: string;
    /**
     * 
     * @type {object}
     * @memberof DataSet
     */
    params?: object;
    /**
     * 
     * @type {Array<string>}
     * @memberof DataSet
     */
    tasks?: Array<string>;
    /**
     * 
     * @type {Array<Transform>}
     * @memberof DataSet
     */
    transforms?: Array<Transform>;
}
/**
 * 
 * @export
 * @interface DatasetRequest
 */
export interface DatasetRequest {
    /**
     * 
     * @type {string}
     * @memberof DatasetRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetRequest
     */
    format?: DatasetRequestFormatEnum;
    /**
     * 
     * @type {string}
     * @memberof DatasetRequest
     */
    name?: string;
    /**
     * 
     * @type {Array<Transform>}
     * @memberof DatasetRequest
     */
    transforms?: Array<Transform>;
}

/**
    * @export
    * @enum {string}
    */
export enum DatasetRequestFormatEnum {
    Coco = 'Coco',
    Custom = 'Custom',
    Ksv = 'Ksv',
    VocDetection = 'VOCDetection',
    VocSegmentation = 'VOCSegmentation'
}

/**
 * 
 * @export
 * @interface DatasetSetting
 */
export interface DatasetSetting {
    /**
     * 
     * @type {number}
     * @memberof DatasetSetting
     */
    endIdx?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DatasetSetting
     */
    indexes?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof DatasetSetting
     */
    startIdx?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DatasetSetting
     */
    useRange?: boolean;
}
/**
 * 
 * @export
 * @interface DefenseRequest
 */
export interface DefenseRequest {
    /**
     * 
     * @type {string}
     * @memberof DefenseRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DefenseRequest
     */
    parameters?: string;
}
/**
 * 
 * @export
 * @interface DefenseResponse
 */
export interface DefenseResponse {
    /**
     * 
     * @type {string}
     * @memberof DefenseResponse
     */
    defenseParameters?: string;
    /**
     * 
     * @type {Array<FilterResponse>}
     * @memberof DefenseResponse
     */
    filters?: Array<FilterResponse>;
    /**
     * 
     * @type {number}
     * @memberof DefenseResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DefenseResponse
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof DefenseResponse
     */
    testId?: number;
}
/**
 * 
 * @export
 * @interface FilterRequest
 */
export interface FilterRequest {
    /**
     * 
     * @type {boolean}
     * @memberof FilterRequest
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FilterRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FilterRequest
     */
    parameters?: string;
}
/**
 * 
 * @export
 * @interface FilterResponse
 */
export interface FilterResponse {
    /**
     * 
     * @type {boolean}
     * @memberof FilterResponse
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FilterResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FilterResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterResponse
     */
    parameters?: string;
    /**
     * 
     * @type {string}
     * @memberof FilterResponse
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface HeadSetting
 */
export interface HeadSetting {
    /**
     * 
     * @type {ModelHead}
     * @memberof HeadSetting
     */
    head?: ModelHead;
    /**
     * 
     * @type {Array<Metric>}
     * @memberof HeadSetting
     */
    metrics?: Array<Metric>;
}
/**
 * 
 * @export
 * @interface InviteRequest
 */
export interface InviteRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InviteRequest
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    apiKey?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    apiKeyId?: string;
}
/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {boolean}
     * @memberof Metric
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    name?: string;
    /**
     * 
     * @type {object}
     * @memberof Metric
     */
    params?: object;
}
/**
 * 
 * @export
 * @interface ModelHead
 */
export interface ModelHead {
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelHead
     */
    losses?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ModelHead
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface OrganizationRequest
 */
export interface OrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof OrganizationRequest
     */
    name?: string;
    /**
     * 
     * @type {OrganizationSettings}
     * @memberof OrganizationRequest
     */
    settings?: OrganizationSettings;
}
/**
 * 
 * @export
 * @interface OrganizationResponse
 */
export interface OrganizationResponse {
    /**
     * 
     * @type {number}
     * @memberof OrganizationResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof OrganizationResponse
     */
    name?: string;
    /**
     * 
     * @type {OrganizationSettings}
     * @memberof OrganizationResponse
     */
    settings?: OrganizationSettings;
}
/**
 * 
 * @export
 * @interface OrganizationSettings
 */
export interface OrganizationSettings {
    /**
     * 
     * @type {Array<string>}
     * @memberof OrganizationSettings
     */
    disabledFeatures?: Array<OrganizationSettingsDisabledFeaturesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganizationSettingsDisabledFeaturesEnum {
    AdvCrafting = 'ADV_CRAFTING',
    Evaluation = 'EVALUATION',
    Robustness = 'ROBUSTNESS'
}

/**
 * 
 * @export
 * @interface PipelineResponse
 */
export interface PipelineResponse {
    /**
     * 
     * @type {number}
     * @memberof PipelineResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PipelineResponse
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ProjectRequest
 */
export interface ProjectRequest {
    /**
     * 
     * @type {Array<ModelHead>}
     * @memberof ProjectRequest
     */
    heads?: Array<ModelHead>;
    /**
     * 
     * @type {string}
     * @memberof ProjectRequest
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectRequest
     */
    name?: string;
    /**
     * 
     * @type {ProjectSettings}
     * @memberof ProjectRequest
     */
    settings?: ProjectSettings;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectRequest
     */
    valid?: boolean;
}
/**
 * 
 * @export
 * @interface ProjectResponse
 */
export interface ProjectResponse {
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    dataRef?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    name?: string;
    /**
     * 
     * @type {OrganizationResponse}
     * @memberof ProjectResponse
     */
    organization?: OrganizationResponse;
    /**
     * 
     * @type {Array<PipelineResponse>}
     * @memberof ProjectResponse
     */
    pipelines?: Array<PipelineResponse>;
    /**
     * 
     * @type {ProjectSettings}
     * @memberof ProjectResponse
     */
    settings?: ProjectSettings;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    uid?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectResponse
     */
    verified?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectResponse
     */
    wrapperRef?: string;
}
/**
 * 
 * @export
 * @interface ProjectSettings
 */
export interface ProjectSettings {
    /**
     * 
     * @type {number}
     * @memberof ProjectSettings
     */
    datasetId?: number;
    /**
     * 
     * @type {Array<HeadSetting>}
     * @memberof ProjectSettings
     */
    headSettings?: Array<HeadSetting>;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectSettings
     */
    storeIntermediateData?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectSettings
     */
    tasks?: Array<string>;
    /**
     * 
     * @type {Array<Transform>}
     * @memberof ProjectSettings
     */
    transforms?: Array<Transform>;
    /**
     * 
     * @type {string}
     * @memberof ProjectSettings
     */
    useTransformsFrom?: ProjectSettingsUseTransformsFromEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectSettingsUseTransformsFromEnum {
    Def = 'def',
    Gui = 'gui',
    Ws = 'ws'
}

/**
 * 
 * @export
 * @interface RegisterRequest
 */
export interface RegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterRequest
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface ReportRequest
 */
export interface ReportRequest {
    /**
     * 
     * @type {string}
     * @memberof ReportRequest
     */
    dataRef?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportRequest
     */
    jsonReport: string;
    /**
     * 
     * @type {number}
     * @memberof ReportRequest
     */
    testId: number;
}
/**
 * 
 * @export
 * @interface ReportResponse
 */
export interface ReportResponse {
    /**
     * 
     * @type {string}
     * @memberof ReportResponse
     */
    dataRef?: string;
    /**
     * 
     * @type {string}
     * @memberof ReportResponse
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ReportResponse
     */
    jsonReport?: string;
    /**
     * 
     * @type {number}
     * @memberof ReportResponse
     */
    testId?: number;
}
/**
 * 
 * @export
 * @interface Resource
 */
export interface Resource {
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof Resource
     */
    file?: any;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    filename?: string;
    /**
     * 
     * @type {object}
     * @memberof Resource
     */
    inputStream?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    open?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Resource
     */
    readable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Resource
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface StatusRequest
 */
export interface StatusRequest {
    /**
     * 
     * @type {number}
     * @memberof StatusRequest
     */
    max?: number;
    /**
     * 
     * @type {string}
     * @memberof StatusRequest
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof StatusRequest
     */
    progress?: number;
    /**
     * 
     * @type {string}
     * @memberof StatusRequest
     */
    status?: StatusRequestStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum StatusRequestStatusEnum {
    Cancelled = 'CANCELLED',
    Done = 'DONE',
    Err = 'ERR',
    Idle = 'IDLE',
    Initializing = 'INITIALIZING',
    Running = 'RUNNING'
}

/**
 * 
 * @export
 * @interface TestRequest
 */
export interface TestRequest {
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    datasetId?: number;
    /**
     * 
     * @type {DefenseResponse}
     * @memberof TestRequest
     */
    defense?: DefenseResponse;
    /**
     * 
     * @type {string}
     * @memberof TestRequest
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    pipelineId?: number;
    /**
     * 
     * @type {number}
     * @memberof TestRequest
     */
    projectId?: number;
    /**
     * 
     * @type {TestSettings}
     * @memberof TestRequest
     */
    testSettings?: TestSettings;
}
/**
 * 
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * 
     * @type {string}
     * @memberof TestResponse
     */
    dataRef?: string;
    /**
     * 
     * @type {number}
     * @memberof TestResponse
     */
    datasetId?: number;
    /**
     * 
     * @type {Array<DefenseResponse>}
     * @memberof TestResponse
     */
    defenses?: Array<DefenseResponse>;
    /**
     * 
     * @type {number}
     * @memberof TestResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TestResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResponse
     */
    modelRef?: string;
    /**
     * 
     * @type {string}
     * @memberof TestResponse
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof TestResponse
     */
    pipelineId?: number;
    /**
     * 
     * @type {number}
     * @memberof TestResponse
     */
    progress?: number;
    /**
     * 
     * @type {number}
     * @memberof TestResponse
     */
    projectId?: number;
    /**
     * 
     * @type {string}
     * @memberof TestResponse
     */
    status?: TestResponseStatusEnum;
    /**
     * 
     * @type {TestSettings}
     * @memberof TestResponse
     */
    testSettings?: TestSettings;
}

/**
    * @export
    * @enum {string}
    */
export enum TestResponseStatusEnum {
    Cancelled = 'CANCELLED',
    Done = 'DONE',
    Err = 'ERR',
    Idle = 'IDLE',
    Initializing = 'INITIALIZING',
    Running = 'RUNNING'
}

/**
 * 
 * @export
 * @interface TestSettings
 */
export interface TestSettings {
    /**
     * 
     * @type {DatasetSetting}
     * @memberof TestSettings
     */
    datasetSetting?: DatasetSetting;
}
/**
 * 
 * @export
 * @interface Transform
 */
export interface Transform {
    /**
     * 
     * @type {number}
     * @memberof Transform
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Transform
     */
    name?: string;
    /**
     * 
     * @type {object}
     * @memberof Transform
     */
    params?: object;
}
/**
 * 
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    jsonSettings?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UserRequest
     */
    organizations?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    roles?: string;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    avatar?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    jsonSettings?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    lastLoginDateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    name?: string;
    /**
     * 
     * @type {Array<OrganizationResponse>}
     * @memberof UserResponse
     */
    organizations?: Array<OrganizationResponse>;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    registered?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    roles?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    uid?: string;
}

/**
 * DefensesApi - axios parameter creator
 * @export
 */
export const DefensesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a defense.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefense: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDefense', 'id', id)
            const localVarPath = `/api/v1/defenses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update defense.
         * @param {number} id id
         * @param {DefenseRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefense: async (id: number, request: DefenseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDefense', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateDefense', 'request', request)
            const localVarPath = `/api/v1/defenses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefensesApi - functional programming interface
 * @export
 */
export const DefensesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefensesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a defense.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefense(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefenseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefense(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update defense.
         * @param {number} id id
         * @param {DefenseRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDefense(id: number, request: DefenseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefenseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDefense(id, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefensesApi - factory interface
 * @export
 */
export const DefensesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefensesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a defense.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefense(id: number, options?: any): AxiosPromise<DefenseResponse> {
            return localVarFp.getDefense(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update defense.
         * @param {number} id id
         * @param {DefenseRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefense(id: number, request: DefenseRequest, options?: any): AxiosPromise<DefenseResponse> {
            return localVarFp.updateDefense(id, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefensesApi - object-oriented interface
 * @export
 * @class DefensesApi
 * @extends {BaseAPI}
 */
export class DefensesApi extends BaseAPI {
    /**
     * 
     * @summary Get a defense.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensesApi
     */
    public getDefense(id: number, options?: any) {
        return DefensesApiFp(this.configuration).getDefense(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update defense.
     * @param {number} id id
     * @param {DefenseRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefensesApi
     */
    public updateDefense(id: number, request: DefenseRequest, options?: any) {
        return DefensesApiFp(this.configuration).updateDefense(id, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KeysApi - axios parameter creator
 * @export
 */
export const KeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a key.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKey', 'id', id)
            const localVarPath = `/api/v1/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a key.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKey', 'id', id)
            const localVarPath = `/api/v1/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all of a user\'s keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeysApi - functional programming interface
 * @export
 */
export const KeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a key.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a key.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all of a user\'s keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KeysApi - factory interface
 * @export
 */
export const KeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeysApiFp(configuration)
    return {
        /**
         * 
         * @summary Create API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(options?: any): AxiosPromise<APIKeyResponse> {
            return localVarFp.createKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a key.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a key.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(id: number, options?: any): AxiosPromise<APIKeyResponse> {
            return localVarFp.getKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all of a user\'s keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys(options?: any): AxiosPromise<Array<APIKeyResponse>> {
            return localVarFp.getKeys(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeysApi - object-oriented interface
 * @export
 * @class KeysApi
 * @extends {BaseAPI}
 */
export class KeysApi extends BaseAPI {
    /**
     * 
     * @summary Create API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public createKey(options?: any) {
        return KeysApiFp(this.configuration).createKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a key.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public deleteKey(id: number, options?: any) {
        return KeysApiFp(this.configuration).deleteKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a key.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public getKey(id: number, options?: any) {
        return KeysApiFp(this.configuration).getKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all of a user\'s keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeysApi
     */
    public getKeys(options?: any) {
        return KeysApiFp(this.configuration).getKeys(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the currently OAuth2 authenticated user platform token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/login/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login app
         * @param {LoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (request: LoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('login', 'request', request)
            const localVarPath = `/api/v1/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the currently OAuth2 authenticated user platform token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login app
         * @param {LoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(request: LoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the currently OAuth2 authenticated user platform token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthUser(options?: any): AxiosPromise<AuthorizedUserResponse> {
            return localVarFp.getAuthUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login app
         * @param {LoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(request: LoginRequest, options?: any): AxiosPromise<AuthorizedUserResponse> {
            return localVarFp.login(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * 
     * @summary Get the currently OAuth2 authenticated user platform token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public getAuthUser(options?: any) {
        return LoginApiFp(this.configuration).getAuthUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login app
     * @param {LoginRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public login(request: LoginRequest, options?: any) {
        return LoginApiFp(this.configuration).login(request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add organization.
         * @param {OrganizationRequest} organization organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganization: async (organization: OrganizationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('addOrganization', 'organization', organization)
            const localVarPath = `/api/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete dataset.
         * @param {number} datasetId The dataset ID.
         * @param {number} id The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDataset: async (datasetId: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteCustomDataset', 'datasetId', datasetId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomDataset', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}/datasets/{datasetId}`
                .replace(`{${"datasetId"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganization', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download dataset data.
         * @param {number} datasetId datasetId
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDataset: async (datasetId: number, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('downloadDataset', 'datasetId', datasetId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadDataset', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}/datasets/{datasetId}`
                .replace(`{${"datasetId"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the datasets defined for this organization.
         * @param {number} id The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasets: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDatasets', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}/datasets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the attacks defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedAttacks: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDefinedAttacks', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}/attacks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the defenses defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedDefenses: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDefinedDefenses', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}/defenses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the metrics defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedMetrics: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDefinedMetrics', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}/metrics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the noises defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedNoises: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDefinedNoises', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}/noises`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the transforms defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedTransforms: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDefinedTransforms', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}/transforms`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organization by id.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganization', 'id', id)
            const localVarPath = `/api/v1/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get organizations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update dataset.
         * @param {number} datasetId The dataset ID.
         * @param {number} id The organization ID.
         * @param {DatasetRequest} datasetRequest The dataset update request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomDataset: async (datasetId: number, id: number, datasetRequest: DatasetRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateCustomDataset', 'datasetId', datasetId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCustomDataset', 'id', id)
            // verify required parameter 'datasetRequest' is not null or undefined
            assertParamExists('updateCustomDataset', 'datasetRequest', datasetRequest)
            const localVarPath = `/api/v1/organizations/{id}/datasets/{datasetId}`
                .replace(`{${"datasetId"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update organization.
         * @param {number} id id
         * @param {OrganizationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (id: number, request: OrganizationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganization', 'id', id)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('updateOrganization', 'request', request)
            const localVarPath = `/api/v1/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload dataset.
         * @param {string} description description
         * @param {'Coco' | 'Custom' | 'Ksv' | 'VOCDetection' | 'VOCSegmentation'} format format
         * @param {number} id The organization ID.
         * @param {string} name name
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDataset: async (description: string, format: 'Coco' | 'Custom' | 'Ksv' | 'VOCDetection' | 'VOCSegmentation', id: number, name: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'description' is not null or undefined
            assertParamExists('uploadDataset', 'description', description)
            // verify required parameter 'format' is not null or undefined
            assertParamExists('uploadDataset', 'format', format)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadDataset', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('uploadDataset', 'name', name)
            const localVarPath = `/api/v1/organizations/{id}/datasets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add organization.
         * @param {OrganizationRequest} organization organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganization(organization: OrganizationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganization(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete dataset.
         * @param {number} datasetId The dataset ID.
         * @param {number} id The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomDataset(datasetId: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomDataset(datasetId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download dataset data.
         * @param {number} datasetId datasetId
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDataset(datasetId: number, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDataset(datasetId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the datasets defined for this organization.
         * @param {number} id The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasets(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasets(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the attacks defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefinedAttacks(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefinedAttacks(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the defenses defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefinedDefenses(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefinedDefenses(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the metrics defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefinedMetrics(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefinedMetrics(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the noises defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefinedNoises(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefinedNoises(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the transforms defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefinedTransforms(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefinedTransforms(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organization by id.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get organizations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizations(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update dataset.
         * @param {number} datasetId The dataset ID.
         * @param {number} id The organization ID.
         * @param {DatasetRequest} datasetRequest The dataset update request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomDataset(datasetId: number, id: number, datasetRequest: DatasetRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomDataset(datasetId, id, datasetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update organization.
         * @param {number} id id
         * @param {OrganizationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(id: number, request: OrganizationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(id, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload dataset.
         * @param {string} description description
         * @param {'Coco' | 'Custom' | 'Ksv' | 'VOCDetection' | 'VOCSegmentation'} format format
         * @param {number} id The organization ID.
         * @param {string} name name
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDataset(description: string, format: 'Coco' | 'Custom' | 'Ksv' | 'VOCDetection' | 'VOCSegmentation', id: number, name: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDataset(description, format, id, name, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add organization.
         * @param {OrganizationRequest} organization organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganization(organization: OrganizationRequest, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.addOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete dataset.
         * @param {number} datasetId The dataset ID.
         * @param {number} id The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomDataset(datasetId: number, id: number, options?: any): AxiosPromise<Array<DataSet>> {
            return localVarFp.deleteCustomDataset(datasetId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download dataset data.
         * @param {number} datasetId datasetId
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDataset(datasetId: number, id: number, options?: any): AxiosPromise<any> {
            return localVarFp.downloadDataset(datasetId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the datasets defined for this organization.
         * @param {number} id The organization ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasets(id: number, options?: any): AxiosPromise<Array<DataSet>> {
            return localVarFp.getDatasets(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the attacks defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedAttacks(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.getDefinedAttacks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the defenses defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedDefenses(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.getDefinedDefenses(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the metrics defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedMetrics(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.getDefinedMetrics(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the noises defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedNoises(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.getDefinedNoises(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the transforms defined for this organization.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefinedTransforms(id: number, options?: any): AxiosPromise<string> {
            return localVarFp.getDefinedTransforms(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organization by id.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(id: number, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.getOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get organizations.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizations(options?: any): AxiosPromise<Array<OrganizationResponse>> {
            return localVarFp.getOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update dataset.
         * @param {number} datasetId The dataset ID.
         * @param {number} id The organization ID.
         * @param {DatasetRequest} datasetRequest The dataset update request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomDataset(datasetId: number, id: number, datasetRequest: DatasetRequest, options?: any): AxiosPromise<Array<DataSet>> {
            return localVarFp.updateCustomDataset(datasetId, id, datasetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update organization.
         * @param {number} id id
         * @param {OrganizationRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(id: number, request: OrganizationRequest, options?: any): AxiosPromise<OrganizationResponse> {
            return localVarFp.updateOrganization(id, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload dataset.
         * @param {string} description description
         * @param {'Coco' | 'Custom' | 'Ksv' | 'VOCDetection' | 'VOCSegmentation'} format format
         * @param {number} id The organization ID.
         * @param {string} name name
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDataset(description: string, format: 'Coco' | 'Custom' | 'Ksv' | 'VOCDetection' | 'VOCSegmentation', id: number, name: string, file?: any, options?: any): AxiosPromise<Array<DataSet>> {
            return localVarFp.uploadDataset(description, format, id, name, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Add organization.
     * @param {OrganizationRequest} organization organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addOrganization(organization: OrganizationRequest, options?: any) {
        return OrganizationApiFp(this.configuration).addOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete dataset.
     * @param {number} datasetId The dataset ID.
     * @param {number} id The organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteCustomDataset(datasetId: number, id: number, options?: any) {
        return OrganizationApiFp(this.configuration).deleteCustomDataset(datasetId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an organization.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganization(id: number, options?: any) {
        return OrganizationApiFp(this.configuration).deleteOrganization(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download dataset data.
     * @param {number} datasetId datasetId
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public downloadDataset(datasetId: number, id: number, options?: any) {
        return OrganizationApiFp(this.configuration).downloadDataset(datasetId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the datasets defined for this organization.
     * @param {number} id The organization ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getDatasets(id: number, options?: any) {
        return OrganizationApiFp(this.configuration).getDatasets(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the attacks defined for this organization.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getDefinedAttacks(id: number, options?: any) {
        return OrganizationApiFp(this.configuration).getDefinedAttacks(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the defenses defined for this organization.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getDefinedDefenses(id: number, options?: any) {
        return OrganizationApiFp(this.configuration).getDefinedDefenses(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the metrics defined for this organization.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getDefinedMetrics(id: number, options?: any) {
        return OrganizationApiFp(this.configuration).getDefinedMetrics(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the noises defined for this organization.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getDefinedNoises(id: number, options?: any) {
        return OrganizationApiFp(this.configuration).getDefinedNoises(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the transforms defined for this organization.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getDefinedTransforms(id: number, options?: any) {
        return OrganizationApiFp(this.configuration).getDefinedTransforms(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organization by id.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganization(id: number, options?: any) {
        return OrganizationApiFp(this.configuration).getOrganization(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get organizations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizations(options?: any) {
        return OrganizationApiFp(this.configuration).getOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update dataset.
     * @param {number} datasetId The dataset ID.
     * @param {number} id The organization ID.
     * @param {DatasetRequest} datasetRequest The dataset update request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateCustomDataset(datasetId: number, id: number, datasetRequest: DatasetRequest, options?: any) {
        return OrganizationApiFp(this.configuration).updateCustomDataset(datasetId, id, datasetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update organization.
     * @param {number} id id
     * @param {OrganizationRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(id: number, request: OrganizationRequest, options?: any) {
        return OrganizationApiFp(this.configuration).updateOrganization(id, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload dataset.
     * @param {string} description description
     * @param {'Coco' | 'Custom' | 'Ksv' | 'VOCDetection' | 'VOCSegmentation'} format format
     * @param {number} id The organization ID.
     * @param {string} name name
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public uploadDataset(description: string, format: 'Coco' | 'Custom' | 'Ksv' | 'VOCDetection' | 'VOCSegmentation', id: number, name: string, file?: any, options?: any) {
        return OrganizationApiFp(this.configuration).uploadDataset(description, format, id, name, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectApi - axios parameter creator
 * @export
 */
export const ProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a project to an organization.
         * @param {number} organizationId The organization ID.
         * @param {ProjectRequest} project project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject: async (organizationId: number, project: ProjectRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addProject', 'organizationId', organizationId)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('addProject', 'project', project)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete project model data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteData: async (dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('deleteData', 'dataType', dataType)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteData', 'id', id)
            const localVarPath = `/api/v1/projects/{id}/modeldata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a project.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProject', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download project data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProjectData: async (dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('downloadProjectData', 'dataType', dataType)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadProjectData', 'id', id)
            const localVarPath = `/api/v1/projects/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a project.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProject', 'id', id)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update project .
         * @param {number} id The project ID.
         * @param {ProjectRequest} projectRequest projectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (id: number, projectRequest: ProjectRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProject', 'id', id)
            // verify required parameter 'projectRequest' is not null or undefined
            assertParamExists('updateProject', 'projectRequest', projectRequest)
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload project data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectData: async (dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('uploadProjectData', 'dataType', dataType)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadProjectData', 'id', id)
            const localVarPath = `/api/v1/projects/{id}/modeldata`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start the model verification process.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyProject: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('verifyProject', 'id', id)
            const localVarPath = `/api/v1/projects/{id}/verify`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a project to an organization.
         * @param {number} organizationId The organization ID.
         * @param {ProjectRequest} project project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProject(organizationId: number, project: ProjectRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProject(organizationId, project, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete project model data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteData(dataType, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a project.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download project data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProjectData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProjectData(dataType, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a project.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProject(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProjects(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProjects(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update project .
         * @param {number} id The project ID.
         * @param {ProjectRequest} projectRequest projectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(id: number, projectRequest: ProjectRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(id, projectRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload project data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProjectData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProjectData(dataType, id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start the model verification process.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyProject(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyProject(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a project to an organization.
         * @param {number} organizationId The organization ID.
         * @param {ProjectRequest} project project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProject(organizationId: number, project: ProjectRequest, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.addProject(organizationId, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete project model data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.deleteData(dataType, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a project.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download project data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProjectData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, options?: any): AxiosPromise<any> {
            return localVarFp.downloadProjectData(dataType, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a project.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProject(id: number, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.getProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProjects(options?: any): AxiosPromise<Array<ProjectResponse>> {
            return localVarFp.getProjects(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update project .
         * @param {number} id The project ID.
         * @param {ProjectRequest} projectRequest projectRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(id: number, projectRequest: ProjectRequest, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.updateProject(id, projectRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload project data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id The project ID.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProjectData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, file?: any, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.uploadProjectData(dataType, id, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start the model verification process.
         * @param {number} id The project ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyProject(id: number, options?: any): AxiosPromise<ProjectResponse> {
            return localVarFp.verifyProject(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Add a project to an organization.
     * @param {number} organizationId The organization ID.
     * @param {ProjectRequest} project project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public addProject(organizationId: number, project: ProjectRequest, options?: any) {
        return ProjectApiFp(this.configuration).addProject(organizationId, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete project model data.
     * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
     * @param {number} id The project ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public deleteData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, options?: any) {
        return ProjectApiFp(this.configuration).deleteData(dataType, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a project.
     * @param {number} id The project ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public deleteProject(id: number, options?: any) {
        return ProjectApiFp(this.configuration).deleteProject(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download project data.
     * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
     * @param {number} id The project ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public downloadProjectData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, options?: any) {
        return ProjectApiFp(this.configuration).downloadProjectData(dataType, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a project.
     * @param {number} id The project ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getProject(id: number, options?: any) {
        return ProjectApiFp(this.configuration).getProject(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of projects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public getProjects(options?: any) {
        return ProjectApiFp(this.configuration).getProjects(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update project .
     * @param {number} id The project ID.
     * @param {ProjectRequest} projectRequest projectRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public updateProject(id: number, projectRequest: ProjectRequest, options?: any) {
        return ProjectApiFp(this.configuration).updateProject(id, projectRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload project data.
     * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
     * @param {number} id The project ID.
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public uploadProjectData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, file?: any, options?: any) {
        return ProjectApiFp(this.configuration).uploadProjectData(dataType, id, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start the model verification process.
     * @param {number} id The project ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public verifyProject(id: number, options?: any) {
        return ProjectApiFp(this.configuration).verifyProject(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegisterApi - axios parameter creator
 * @export
 */
export const RegisterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register user
         * @param {RegisterRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (request: RegisterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('register', 'request', request)
            const localVarPath = `/api/v1/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send user invite
         * @param {InviteRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvite: async (request: InviteRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('sendInvite', 'request', request)
            const localVarPath = `/api/v1/register/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegisterApi - functional programming interface
 * @export
 */
export const RegisterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegisterApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register user
         * @param {RegisterRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(request: RegisterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizedUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Send user invite
         * @param {InviteRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInvite(request: InviteRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendInvite(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegisterApi - factory interface
 * @export
 */
export const RegisterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegisterApiFp(configuration)
    return {
        /**
         * 
         * @summary Register user
         * @param {RegisterRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(request: RegisterRequest, options?: any): AxiosPromise<AuthorizedUserResponse> {
            return localVarFp.register(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send user invite
         * @param {InviteRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvite(request: InviteRequest, options?: any): AxiosPromise<void> {
            return localVarFp.sendInvite(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegisterApi - object-oriented interface
 * @export
 * @class RegisterApi
 * @extends {BaseAPI}
 */
export class RegisterApi extends BaseAPI {
    /**
     * 
     * @summary Register user
     * @param {RegisterRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
    public register(request: RegisterRequest, options?: any) {
        return RegisterApiFp(this.configuration).register(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send user invite
     * @param {InviteRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisterApi
     */
    public sendInvite(request: InviteRequest, options?: any) {
        return RegisterApiFp(this.configuration).sendInvite(request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add report.
         * @param {ReportRequest} report report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addReport: async (report: ReportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'report' is not null or undefined
            assertParamExists('addReport', 'report', report)
            const localVarPath = `/api/v1/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(report, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a report.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteReport', 'id', id)
            const localVarPath = `/api/v1/reports/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download report data.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadReportData: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadReportData', 'id', id)
            const localVarPath = `/api/v1/reports/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a report.
         * @param {number} reportId reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport: async (reportId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReport', 'reportId', reportId)
            const localVarPath = `/api/v1/reports/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get reports for a test.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports: async (testId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getReports', 'testId', testId)
            const localVarPath = `/api/v1/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (testId !== undefined) {
                localVarQueryParameter['testId'] = testId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary View report data.
         * @param {number} aidx aidx
         * @param {number} didx didx
         * @param {number} id id
         * @param {number} idx idx
         * @param {string} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewData: async (aidx: number, didx: number, id: number, idx: number, tag: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aidx' is not null or undefined
            assertParamExists('viewData', 'aidx', aidx)
            // verify required parameter 'didx' is not null or undefined
            assertParamExists('viewData', 'didx', didx)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('viewData', 'id', id)
            // verify required parameter 'idx' is not null or undefined
            assertParamExists('viewData', 'idx', idx)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('viewData', 'tag', tag)
            const localVarPath = `/api/v1/reports/{id}/{didx}/{aidx}/{idx}/{tag}`
                .replace(`{${"aidx"}}`, encodeURIComponent(String(aidx)))
                .replace(`{${"didx"}}`, encodeURIComponent(String(didx)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"idx"}}`, encodeURIComponent(String(idx)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add report.
         * @param {ReportRequest} report report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addReport(report: ReportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addReport(report, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a report.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReport(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReport(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download report data.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadReportData(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadReportData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a report.
         * @param {number} reportId reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReport(reportId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReport(reportId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get reports for a test.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReports(testId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReportResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReports(testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary View report data.
         * @param {number} aidx aidx
         * @param {number} didx didx
         * @param {number} id id
         * @param {number} idx idx
         * @param {string} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async viewData(aidx: number, didx: number, id: number, idx: number, tag: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.viewData(aidx, didx, id, idx, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add report.
         * @param {ReportRequest} report report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addReport(report: ReportRequest, options?: any): AxiosPromise<ReportResponse> {
            return localVarFp.addReport(report, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a report.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReport(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download report data.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadReportData(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.downloadReportData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a report.
         * @param {number} reportId reportId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReport(reportId: number, options?: any): AxiosPromise<ReportResponse> {
            return localVarFp.getReport(reportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get reports for a test.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReports(testId: number, options?: any): AxiosPromise<Array<ReportResponse>> {
            return localVarFp.getReports(testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary View report data.
         * @param {number} aidx aidx
         * @param {number} didx didx
         * @param {number} id id
         * @param {number} idx idx
         * @param {string} tag tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        viewData(aidx: number, didx: number, id: number, idx: number, tag: string, options?: any): AxiosPromise<any> {
            return localVarFp.viewData(aidx, didx, id, idx, tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * 
     * @summary Add report.
     * @param {ReportRequest} report report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public addReport(report: ReportRequest, options?: any) {
        return ReportsApiFp(this.configuration).addReport(report, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a report.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public deleteReport(id: number, options?: any) {
        return ReportsApiFp(this.configuration).deleteReport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download report data.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public downloadReportData(id: number, options?: any) {
        return ReportsApiFp(this.configuration).downloadReportData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a report.
     * @param {number} reportId reportId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReport(reportId: number, options?: any) {
        return ReportsApiFp(this.configuration).getReport(reportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get reports for a test.
     * @param {number} testId testId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReports(testId: number, options?: any) {
        return ReportsApiFp(this.configuration).getReports(testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary View report data.
     * @param {number} aidx aidx
     * @param {number} didx didx
     * @param {number} id id
     * @param {number} idx idx
     * @param {string} tag tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public viewData(aidx: number, didx: number, id: number, idx: number, tag: string, options?: any) {
        return ReportsApiFp(this.configuration).viewData(aidx, didx, id, idx, tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestApi - axios parameter creator
 * @export
 */
export const TestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add attack.
         * @param {number} testId testId
         * @param {FilterRequest} attackRequest attackRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttack: async (testId: number, attackRequest: FilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('addAttack', 'testId', testId)
            // verify required parameter 'attackRequest' is not null or undefined
            assertParamExists('addAttack', 'attackRequest', attackRequest)
            const localVarPath = `/api/v1/tests/{testId}/attack`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add defense.
         * @param {number} testId The test id.
         * @param {DefenseRequest} defenseRequest defenseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDefense: async (testId: number, defenseRequest: DefenseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('addDefense', 'testId', testId)
            // verify required parameter 'defenseRequest' is not null or undefined
            assertParamExists('addDefense', 'defenseRequest', defenseRequest)
            const localVarPath = `/api/v1/tests/{testId}/defense`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defenseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add noise.
         * @param {number} id id
         * @param {FilterRequest} filterRequest filterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoise: async (id: number, filterRequest: FilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addNoise', 'id', id)
            // verify required parameter 'filterRequest' is not null or undefined
            assertParamExists('addNoise', 'filterRequest', filterRequest)
            const localVarPath = `/api/v1/tests/{id}/noise`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add new test.
         * @param {TestRequest} test test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTest: async (test: TestRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'test' is not null or undefined
            assertParamExists('addTest', 'test', test)
            const localVarPath = `/api/v1/tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(test, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a test.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTest', 'id', id)
            const localVarPath = `/api/v1/tests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get defenses.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefenses: async (testId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getDefenses', 'testId', testId)
            const localVarPath = `/api/v1/tests/{testId}/defenses`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get test status.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (testId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getStatus', 'testId', testId)
            const localVarPath = `/api/v1/tests/{testId}/status`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tests.
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTests: async (projectId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getTests', 'projectId', projectId)
            const localVarPath = `/api/v1/tests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove defense.
         * @param {number} id The defense id.
         * @param {number} testId The test id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDefense: async (id: number, testId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeDefense', 'id', id)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('removeDefense', 'testId', testId)
            const localVarPath = `/api/v1/tests/{testId}/defense/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove filter.
         * @param {number} id The filter id.
         * @param {number} testId The test id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFilter: async (id: number, testId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeFilter', 'id', id)
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('removeFilter', 'testId', testId)
            const localVarPath = `/api/v1/tests/{testId}/filter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a test.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTest: async (testId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('startTest', 'testId', testId)
            const localVarPath = `/api/v1/tests/{testId}/start`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop a test.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTest: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopTest', 'id', id)
            const localVarPath = `/api/v1/tests/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update test status.
         * @param {number} testId testId
         * @param {StatusRequest} status status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus: async (testId: number, status: StatusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('updateStatus', 'testId', testId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateStatus', 'status', status)
            const localVarPath = `/api/v1/tests/{testId}/status`
                .replace(`{${"testId"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(status, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update test.
         * @param {number} id The test ID.
         * @param {TestRequest} testRequest testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest: async (id: number, testRequest: TestRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTest', 'id', id)
            // verify required parameter 'testRequest' is not null or undefined
            assertParamExists('updateTest', 'testRequest', testRequest)
            const localVarPath = `/api/v1/tests/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id id
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadData: async (dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('uploadData', 'dataType', dataType)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadData', 'id', id)
            const localVarPath = `/api/v1/tests/{id}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestApi - functional programming interface
 * @export
 */
export const TestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add attack.
         * @param {number} testId testId
         * @param {FilterRequest} attackRequest attackRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAttack(testId: number, attackRequest: FilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAttack(testId, attackRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add defense.
         * @param {number} testId The test id.
         * @param {DefenseRequest} defenseRequest defenseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDefense(testId: number, defenseRequest: DefenseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDefense(testId, defenseRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add noise.
         * @param {number} id id
         * @param {FilterRequest} filterRequest filterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNoise(id: number, filterRequest: FilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNoise(id, filterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add new test.
         * @param {TestRequest} test test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTest(test: TestRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTest(test, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a test.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTest(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTest(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get defenses.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefenses(testId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DefenseResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefenses(testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get test status.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(testId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get tests.
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTests(projectId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TestResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTests(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove defense.
         * @param {number} id The defense id.
         * @param {number} testId The test id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDefense(id: number, testId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDefense(id, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove filter.
         * @param {number} id The filter id.
         * @param {number} testId The test id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFilter(id: number, testId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFilter(id, testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a test.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startTest(testId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startTest(testId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop a test.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopTest(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopTest(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update test status.
         * @param {number} testId testId
         * @param {StatusRequest} status status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatus(testId: number, status: StatusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatus(testId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update test.
         * @param {number} id The test ID.
         * @param {TestRequest} testRequest testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTest(id: number, testRequest: TestRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTest(id, testRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id id
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadData(dataType, id, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestApi - factory interface
 * @export
 */
export const TestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestApiFp(configuration)
    return {
        /**
         * 
         * @summary Add attack.
         * @param {number} testId testId
         * @param {FilterRequest} attackRequest attackRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttack(testId: number, attackRequest: FilterRequest, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.addAttack(testId, attackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add defense.
         * @param {number} testId The test id.
         * @param {DefenseRequest} defenseRequest defenseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDefense(testId: number, defenseRequest: DefenseRequest, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.addDefense(testId, defenseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add noise.
         * @param {number} id id
         * @param {FilterRequest} filterRequest filterRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNoise(id: number, filterRequest: FilterRequest, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.addNoise(id, filterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add new test.
         * @param {TestRequest} test test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTest(test: TestRequest, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.addTest(test, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a test.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get defenses.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefenses(testId: number, options?: any): AxiosPromise<Array<DefenseResponse>> {
            return localVarFp.getDefenses(testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get test status.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(testId: number, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.getStatus(testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get tests.
         * @param {number} projectId projectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTests(projectId: number, options?: any): AxiosPromise<Array<TestResponse>> {
            return localVarFp.getTests(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove defense.
         * @param {number} id The defense id.
         * @param {number} testId The test id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDefense(id: number, testId: number, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.removeDefense(id, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove filter.
         * @param {number} id The filter id.
         * @param {number} testId The test id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFilter(id: number, testId: number, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.removeFilter(id, testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a test.
         * @param {number} testId testId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startTest(testId: number, options?: any): AxiosPromise<void> {
            return localVarFp.startTest(testId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop a test.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTest(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.stopTest(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update test status.
         * @param {number} testId testId
         * @param {StatusRequest} status status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatus(testId: number, status: StatusRequest, options?: any): AxiosPromise<boolean> {
            return localVarFp.updateStatus(testId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update test.
         * @param {number} id The test ID.
         * @param {TestRequest} testRequest testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest(id: number, testRequest: TestRequest, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.updateTest(id, testRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload data.
         * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
         * @param {number} id id
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, file?: any, options?: any): AxiosPromise<TestResponse> {
            return localVarFp.uploadData(dataType, id, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export class TestApi extends BaseAPI {
    /**
     * 
     * @summary Add attack.
     * @param {number} testId testId
     * @param {FilterRequest} attackRequest attackRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public addAttack(testId: number, attackRequest: FilterRequest, options?: any) {
        return TestApiFp(this.configuration).addAttack(testId, attackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add defense.
     * @param {number} testId The test id.
     * @param {DefenseRequest} defenseRequest defenseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public addDefense(testId: number, defenseRequest: DefenseRequest, options?: any) {
        return TestApiFp(this.configuration).addDefense(testId, defenseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add noise.
     * @param {number} id id
     * @param {FilterRequest} filterRequest filterRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public addNoise(id: number, filterRequest: FilterRequest, options?: any) {
        return TestApiFp(this.configuration).addNoise(id, filterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add new test.
     * @param {TestRequest} test test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public addTest(test: TestRequest, options?: any) {
        return TestApiFp(this.configuration).addTest(test, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a test.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public deleteTest(id: number, options?: any) {
        return TestApiFp(this.configuration).deleteTest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get defenses.
     * @param {number} testId testId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getDefenses(testId: number, options?: any) {
        return TestApiFp(this.configuration).getDefenses(testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get test status.
     * @param {number} testId testId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getStatus(testId: number, options?: any) {
        return TestApiFp(this.configuration).getStatus(testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get tests.
     * @param {number} projectId projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public getTests(projectId: number, options?: any) {
        return TestApiFp(this.configuration).getTests(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove defense.
     * @param {number} id The defense id.
     * @param {number} testId The test id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public removeDefense(id: number, testId: number, options?: any) {
        return TestApiFp(this.configuration).removeDefense(id, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove filter.
     * @param {number} id The filter id.
     * @param {number} testId The test id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public removeFilter(id: number, testId: number, options?: any) {
        return TestApiFp(this.configuration).removeFilter(id, testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a test.
     * @param {number} testId testId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public startTest(testId: number, options?: any) {
        return TestApiFp(this.configuration).startTest(testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop a test.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public stopTest(id: number, options?: any) {
        return TestApiFp(this.configuration).stopTest(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update test status.
     * @param {number} testId testId
     * @param {StatusRequest} status status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public updateStatus(testId: number, status: StatusRequest, options?: any) {
        return TestApiFp(this.configuration).updateStatus(testId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update test.
     * @param {number} id The test ID.
     * @param {TestRequest} testRequest testRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public updateTest(id: number, testRequest: TestRequest, options?: any) {
        return TestApiFp(this.configuration).updateTest(id, testRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload data.
     * @param {'Dataset' | 'Model' | 'WrapperScript'} dataType dataType
     * @param {number} id id
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public uploadData(dataType: 'Dataset' | 'Model' | 'WrapperScript', id: number, file?: any, options?: any) {
        return TestApiFp(this.configuration).uploadData(dataType, id, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a user.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the currently logged-in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update profile of currently authenticated user.
         * @param {UserRequest} userRequest userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (userRequest: UserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('updateProfile', 'userRequest', userRequest)
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user.
         * @param {number} id id
         * @param {UserRequest} userRequest userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: number, userRequest: UserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'userRequest' is not null or undefined
            assertParamExists('updateUser', 'userRequest', userRequest)
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication JWT required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a user.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the currently logged-in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggedInUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLoggedInUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update profile of currently authenticated user.
         * @param {UserRequest} userRequest userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(userRequest: UserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user.
         * @param {number} id id
         * @param {UserRequest} userRequest userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: number, userRequest: UserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, userRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a user.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the currently logged-in user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInUser(options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getLoggedInUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user.
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: number, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): AxiosPromise<Array<UserResponse>> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update profile of currently authenticated user.
         * @param {UserRequest} userRequest userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(userRequest: UserRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.updateProfile(userRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user.
         * @param {number} id id
         * @param {UserRequest} userRequest userRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: number, userRequest: UserRequest, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.updateUser(id, userRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Delete a user.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(id: number, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the currently logged-in user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getLoggedInUser(options?: any) {
        return UsersApiFp(this.configuration).getLoggedInUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user.
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: number, options?: any) {
        return UsersApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(options?: any) {
        return UsersApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update profile of currently authenticated user.
     * @param {UserRequest} userRequest userRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateProfile(userRequest: UserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateProfile(userRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user.
     * @param {number} id id
     * @param {UserRequest} userRequest userRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(id: number, userRequest: UserRequest, options?: any) {
        return UsersApiFp(this.configuration).updateUser(id, userRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


